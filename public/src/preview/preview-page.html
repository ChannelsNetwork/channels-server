<link rel="import" href="../card/card-feed.html">
<link rel="import" href="../../bower_components/paper-fab/paper-fab.html">
<link rel="import" href="../../bower_components/iron-icons/iron-icons.html">

<dom-module id="preview-page">
  <template>
    <style is="custom-style" include="app-styles iron-flex iron-flex-alignment">
      :host {
        display: block;
        background: #fafafa;
        color: #000;
        min-height: 100vh;
      }

      .main {
        padding: 0 0 20px;
      }

      .header {
        padding: 20px;
        max-width: 1180px;
        margin: 0 auto;
      }

      .header div {
        max-width: 800px;
      }

      #feed {
        max-width: 1200px;
        margin: 0 auto;
        box-sizing: border-box;
      }

      .composeButton {
        position: fixed;
        bottom: 32px;
        right: 32px;
        --paper-fab-background: #f9ed00;
        color: black;
      }

      @media (max-width: 600px) {
        .header {
          padding: 5px 10px;
          font-size: 14px;
        }
        .composeButton {
          bottom: 24px;
          right: 16px;
        }
      }
    </style>
    <div class="barspace"></div>
    <div class="header" style="display:none;">
      <div>
        <p>
          This is an example of what your feed will look like when we go live.
        </p>
        <p>
          You can see a variety of cards, each with its own price tag. These cards do not yet have content but if they did, when you
          tap on one, your balance would go down or up accordingly.
        </p>
      </div>
    </div>
    <div class="main">
      <card-feed id="feed" items="[[items]]" on-card-click="onCardClick" on-card-closed="onCardClosed" on-card-payment-due="onCardPay"
        intersection-observer="[[intersectionObserver]]"></card-feed>
    </div>
    <paper-fab class="composeButton" icon="add" on-tap="onCompose"></paper-fab>
  </template>
  <script>
    class PreviewPage extends Polymer.Element {
      static get is() { return "preview-page"; }
      static get properties() {
        return {
          items: Array,
          intersectionObserver: Object
        }
      }

      connectedCallback() {
        super.connectedCallback();
        this._visibleCards = {};
        $core.register().then((info) => {
          const options = {
            root: $app.shell,
            rootMargin: "0px",
            threshold: 1.0
          };
          const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
              this.onCardObserved(entry);
            });
          }, options);
          this.set('intersectionObserver', observer);
          this._timer = setInterval(() => {
            this._onTimer();
          }, 100);
          return $core.getFeed('new', 25).then((cards) => {
            this.items = cards;
          });
        }).catch((err) => {
          console.error(err);
          setTimeout(() => {
            $router.goto("");
          }, 600);
        });
      }

      disconnectedCallback() {
        super.disconnectedCallback();
        if (this._timer) {
          clearInterval(this._timer);
        }
      }

      onActivate() {
        this._barShowing = true;
        this._prevScrollValue = 0;
        this._preventScroll = false;
        this._scrollListener = () => {
          if (!this._preventScroll) {
            this.onScroll();
          }
        };
        $app.shell.addEventListener("scroll", this._scrollListener);

        this._resizeListener = _debounce(() => {
          this.onResize();
        }, 350);
        window.addEventListener("resize", this._resizeListener);
        this.onResize();
      }

      onDeactivate() {
        if (this._scrollListener) {
          $app.shell.removeEventListener("scroll", this._scrollListener);
          this._scrollListener = null;
        }
        if (this._resizeListener) {
          window.removeEventListener("resize", this._resizeListener);
          this._resizeListener = null;
        }
      }

      onResize() {
        this.$.feed.refreshLayout();
      }

      onScroll() {
        if (!this._prevScrollValue) {
          this._prevScrollValue = $app.shell.scrollTop;
        } else {
          if ($app.shell.scrollTop <= 0) {
            this._prevScrollValue = 0;
            if (!this._barShowing) {
              this._barShowing = true;
              $app.setBarVisible(true);
            }
            return;
          }
          let diff = $app.shell.scrollTop - this._prevScrollValue;
          if (diff > 10) {
            this._prevScrollValue = $app.shell.scrollTop;
            if (this._barShowing) {
              this._barShowing = false;
              $app.setBarVisible(false);
            }
          } else if (diff < -5) {
            this._prevScrollValue = $app.shell.scrollTop;
            if (!this._barShowing) {
              this._barShowing = true;
              $app.setBarVisible(true);
            }
          }
        }
      }

      onCardClosed(event) {
        this._barShowing = true;
        $app.setBarVisible(true);
        let cardItem = event.detail.item;
        if (cardItem) {
          $core.cardClosed(cardItem.id);
        }
      }

      onCardClick(event) {
        let card = event.detail.card;
        if (card) {
          this._barShowing = false;
          $app.setBarVisible(false);
          this._preventScroll = true;
          let cardItem = event.detail.item;
          if (cardItem) {
            $core.cardOpened(cardItem.id);
          }
          this.$.feed.openCard(card).then(() => {
            this._preventScroll = false;
          }).catch((err) => {
            this._preventScroll = false;
          });
        }
      }

      onCardPay(event) {
        const card = event.detail.item;
        const cardView = event.detail.card;
        if (card.pricing.openFee > 0 && !card.userSpecific.paid) {
          card.userSpecific.paid = card.pricing.openFee;
          $core.cardPay(card.id, card.pricing.openFee, card.by.address, null, 0, null, null, null).then((response) => {
            card.history.revenue = response.totalCardRevenue;
            cardView.onPayment();
          });
        } else if (card.pricing.openFee < 0 && !card.userSpecific.earned && card.couponId) {
          card.userSpecific.earned = -card.pricing.openFee;
          $core.cardOpenPaymentRedeem(card.id, card.couponId);
          cardView.onPayment();
        }
      }

      onCardObserved(entry) {
        if (entry.intersectionRatio > 0.9) {
          if (!this._visibleCards[entry.target.data.id]) {
            this._visibleCards[entry.target.data.id] = entry.target;
            entry.target.impressionStarted = Date.now();
          }
        } else {
          delete entry.target.impressionStarted;
          delete this._visibleCards[entry.target.data.id];
        }
      }

      onCompose() {
        if (!$core.profile || !$core.profile.handle) {
          $router.goto("edit-profile", { message: "Before you compose your first card, you must first register an identity.", returnRoute: { success: "compose", cancel: "feed" } });
          return;
        }
        $router.goto("compose");
      }

      _onTimer() {
        for (const id of Object.keys(this._visibleCards)) {
          const card = this._visibleCards[id];
          if (!card.impressionSent && Date.now() - card.impressionStarted > 2000) {
            card.impressionSent = true;
            if (card.data.pricing.promotionFee && card.data.userSpecific.earned === 0 && card.data.couponId) {
              $core.cardImpression(id, card.data.couponId);
              card.data.userSpecific.earned = card.data.pricing.promotionFee;
              card.onImpressionPaid();
            } else {
              $core.cardImpression(id);
            }
          }
        }
      }
    }
    window.customElements.define(PreviewPage.is, PreviewPage);
  </script>
</dom-module>