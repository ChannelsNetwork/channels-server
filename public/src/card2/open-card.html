<link rel="import" href="open-card-header.html">
<dom-module id="open-card">
  <template>
    <style is="custom-style" include="app-styles2">
      :host {
        display: none;
        position: absolute;
        top: 0;
        left: 0;
        height: 100%;
        width: 100%;
        box-sizing: border-box;
        transition: all 0.8s ease;
        z-index: 1;
        pointer-events: auto;
      }

      #container {
        width: 100%;
        height: 100%;
        box-sizing: border-box;
        box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12), 0 3px 1px -2px rgba(0, 0, 0, 0.2);
        border-radius: 3px;
        overflow: hidden;
        position: relative;
        background: white;
        opacity: 0;
        transition: opacity 1s ease;
      }

      #headerBuffer {
        display: block;
        box-sizing: border-box;
        height: 60px;
      }

      #header {
        position: absolute;
        left: 0;
        right: 0;
        bottom: 0;
        box-sizing: border-box;
        border-radius: 3px 3px 0 0;
        overflow: hidden;
        box-shadow: 0 1px 5px -1px rgba(0, 0, 0, 0.2);
      }

      .content {
        position: relative;
        overflow-x: hidden;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
      }

      #loadingPanel {
        max-width: 800px;
        margin: 0 auto;
        padding: 10px;
        font-size: 20px;
        color: #212121;
        text-align: center;
      }

      .animatable {
        transition: all 0.8s ease;
      }
    </style>
    <div id="container" class="vertical layout">
      <div id="headerBuffer"></div>
      <div class="content flex">
        <div id="loadingPanel">
          <p>Loading...</p>
        </div>
        <div id="cardView" class="hidden"></div>
      </div>
    </div>
    <open-card-header id="header" data="[[data]]"></open-card-header>
  </template>
  <script>
    class OpenCard extends Polymer.Element {
      static get is() { return 'open-card'; }
      static get properties() {
        return {
          data: Object
        };
      }

      open(node) {
        if (this._open) {
          return;
        }
        this._open = true;
        this._refNode = node;
        return new Promise((resolve, reject) => {
          this.style.display = "block";
          requestAnimationFrame(() => {
            this.$.header.style.bottom = "initial";
            this.$.header.style.top = (this.offsetHeight - 60) + "px";
            this.$.header.classList.add("animatable");
            this.$.container.style.opacity = 1;
            let nodeRect = node.getBoundingClientRect();
            let cardRect = this.getBoundingClientRect();
            this.style.top = (nodeRect.top - cardRect.top) + "px";
            this.style.left = (nodeRect.left - cardRect.left) + "px";
            this.style.width = nodeRect.width + "px"
            this.style.height = nodeRect.height + "px";
            requestAnimationFrame(() => {
              this.$.header.style.top = "0px";
              resolve();
            });
            this._loadCard();
          });
        });
      }

      close() {
        if (!this._open) {
          return;
        }
        this._open = false;
        this._stopPaymentTimer();
        this._refNode = null;
        this.style.display = "none";
        this.$.header.style.bottom = "0";
        this.$.header.style.top = "initial"
        this.$.header.classList.remove("animatable");
        this.$.container.style.opacity = 0;
        this.style.top = 0;
        this.style.left = 0;
        this.style.width = "100%";
        this.style.height = "100%";
      }

      refreshLayout(cardNode) {
        if (this._refNode) {
          let nodeRect = this._refNode.getBoundingClientRect();
          let cardRect = cardNode.getBoundingClientRect();
          this.style.top = (nodeRect.top - cardRect.top) + "px";
          this.style.left = (nodeRect.left - cardRect.left) + "px";
          this.style.width = nodeRect.width + "px"
          this.style.height = nodeRect.height + "px";
        }
      }

      _clearNode(node) {
        while (node.hasChildNodes()) {
          node.removeChild(node.lastChild);
        }
      }

      _loadCard() {
        if (this._loading) {
          return;
        }
        this._loading = true;
        this._loadingStart = (new Date()).getTime();
        this.$.loadingPanel.classList.remove("hidden");
        this.$.cardView.classList.add("hidden");
        this._clearNode(this.$.cardView);
        let cardId = this.data.id;
        if (!cardId) {
          this._loading = false;
          this.$.loadingPanel.classList.add("hidden");
          return;
        }
        let promoted = this.data.promoted;

        // Fetch the card, then ensure the card package is on the serever, 
        // then import the viewer component, then insert the viewer component
        $core.getCard(cardId).then((cardData) => {
          cardData.card.promoted = promoted;
          this.set("data", cardData.card);
          let packageName = this.data.cardType.package;
          if (!packageName) {
            this._loading = false;
            this.$.loadingPanel.classList.add("hidden");
            return;
          }
          // Import card package
          return $core.cardManager.ensurePackage(packageName).then((packageInfo) => {
            // Import viewer
            return this._import(packageInfo.importHref).then(() => {
              let now = (new Date()).getTime();
              let diff = now - (this._loadingStart || 0);
              if (diff >= 1100) {
                this._onCardLoaded(true, packageInfo);
              } else {
                setTimeout(() => {
                  this._onCardLoaded(true, packageInfo);
                }, diff);
              }
            });
          });
        }).catch((err) => {
          this._onCardLoaded(false);
          console.error("Failed to open card", err);
        });
      }

      _onCardLoaded(success, packageInfo) {
        this._loading = false;
        this.$.loadingPanel.classList.add("hidden");
        this.$.cardView.classList.remove("hidden");

        if (success && packageInfo) {
          this._insertCardNode(packageInfo);
          requestAnimationFrame(() => {
            if (this._open) {
              this._startPaymentTimer();
            }
          });
        }
      }

      _insertCardNode(packageInfo) {
        let cardNode = document.createElement(packageInfo.channelComponent.viewerTag);
        cardNode.sharedState = this.data.state.shared;
        cardNode.userState = this.data.state.user;
        cardNode.author = this.data.by;
        cardNode.user = $core.profile;
        this.$.cardView.appendChild(cardNode);
      }

      _import(url) {
        return new Promise((resolve, reject) => {
          Polymer.importHref(url, () => {
            resolve();
          }, (err) => {
            reject(err);
          });
        });
      }

      _stopPaymentTimer() {
        if (this._paymentTimer) {
          clearTimeout(this._paymentTimer);
          this._paymentTimer = null;
          this._prevOpenDuration = (new Date()).getTime() - this._paymentTimerStart;
        }
        this.$.header.hideTimer();
      }

      _startPaymentTimer() {
        if (this._paymentTimer) {
          return;
        }
        let startTimer = false;
        if (!this.data.userSpecific.isPoster) {
          if ((this.data.pricing.openFee > 0 && this.data.userSpecific.paidToAuthor === 0) ||
            (this.data.pricing.openFee < 0 && this.data.promoted && this.data.userSpecific.earnedFromAuthor == 0)) {
            startTimer = true;
          }
        }
        if (!startTimer) {
          return;
        }
        this._prevOpenDuration = this._prevOpenDuration || 0;
        if (this._prevOpenDuration >= 10000) {
          this._onPaymentDue();
        } else {
          this._paymentTimerStart = (new Date()).getTime();
          this._paymentTimerInterval = 10000 - this._prevOpenDuration;
          this._paymentTimer = setInterval(() => {
            if (this._open) {
              let now = (new Date()).getTime();
              if ((now - this._paymentTimerStart) >= this._paymentTimerInterval) {
                this._onPaymentDue();
              } else {
                let value = (((now - this._paymentTimerStart) + this._prevOpenDuration) / 10000) * 100;
                this.$.header.showTimer(value);
              }
            }
          }, 100);
        }
      }

      _onPaymentDue() {
        if (this._paymentTimer) {
          clearInterval(this._paymentTimer);
          this._paymentTimer = null;
        }
        this.$.header.hideTimer();
        this.dispatchEvent(new CustomEvent('card-payment-due', { bubbles: true, composed: true }));
      }

      onPayment() {
        this.$.header.onPayment();
      }
    }
    window.customElements.define(OpenCard.is, OpenCard);
  </script>
</dom-module>