<dom-module id="feed-styles">
  <template>
    <style>
      :host {
        display: block;
        background: #fafafa !important;
      }

      .main {
        padding: 0 0 90px;
      }

      .spacer {
        height: 40px;
      }

      #feed {
        max-width: 1264px;
        margin: 0 auto;
        box-sizing: border-box;
      }

      #noItems {
        padding: 20px;
        font-size: 16px;
        letter-spacing: 0.05em;
        text-align: center;
      }
    </style>
  </template>
</dom-module>
<script>
  (function () {
    window.FeedMixin = (base) => class extends base {
      static get properties() {
        return {
          items: Array,
          iconMap: Object
        };
      }

      constructor() {
        super();
        this.iconMap = window._channelIcons;
      }

      _parseRoute(route) {
        // TODO: super class needs to reimplement
      }

      _onDataFetch(parsedRoute) {
        // TODO: super class may implement this to fetch specific data
      }

      _onActivate() {
        // super class may implement
      }

      _onDeactivate() {
        // super class may implement
      }

      onActivate(route) {
        this._onActivate();
        $core.register().then(() => {
          // register event handlers
          this._resizeListener = _debounce(() => {
            this._onResize();
          }, 350);
          window.addEventListener("resize", this._resizeListener);
          this._onResize();

          // parse route and fetch only if route is different
          let fetchNewContent = true;
          let parsedRoute = this._parseRoute(route);
          if (!window.__dirtyFeed) {
            if (this._parsedRoute && this._lastFetchTimestamp) {
              if (parsedRoute.path === this._parsedRoute.path) {
                let timeDiff = (new Date()).getTime() - this._lastFetchTimestamp;
                if (timeDiff < (5 * 60 * 1000)) {
                  fetchNewContent = false;
                }
              }
            }
          }
          if (!fetchNewContent) {
            $app.scrollTo(route.context.scrollTop);
            return;
          }

          // clear state
          this._setItems([]);
          window.__dirtyFeed = false;

          this._parsedRoute = parsedRoute;
          this._lastFetchTimestamp = (new Date()).getTime();
          this._moreAvailable = false;
          this._onMoreUpdated(this._moreAvailable);
          this._promotedCardIds = [];
          if (parsedRoute) {
            this._onDataFetch(parsedRoute);
            return $core.getFeed(parsedRoute.feedName, parsedRoute.count, parsedRoute.cardId, null, parsedRoute.channel, this._promotedCardIds).then((feed) => {
              const cards = feed.cards;
              this._lastCardId = null;
              for (const card of cards) {
                if (card.promoted) {
                  this._promotedCardIds.push(card.id);
                } else {
                  this._lastCardId = card.id;
                }
              }
              this._setItems(cards);
              if (cards && cards.length) {
                this.$.noItems.classList.add("hidden");
              } else {
                this.$.noItems.classList.remove("hidden");
              }
              this._moreAvailable = feed.moreAvailable && this._lastCardId ? true : false;
              this._onMoreUpdated(this._moreAvailable);
            });
          }
        });
      }

      _setItems(items) {
        this.set("items", items);
      }

      _appendItems(items) {
        for (const item of items) {
          this.push('items', item);
        }
      }

      onDeactivate() {
        this._onDeactivate();
        if (this._resizeListener) {
          window.removeEventListener("resize", this._resizeListener);
          this._resizeListener = null;
        }
      }

      _onResize() {
        this.$.feed.refreshLayout();
        if (this.$.promotedFeed) {
          this.$.promotedFeed.refreshLayout();
        }
      }

      _onCardOpenRequest(event) {
        let card = event.detail.item;
        if (card) {
          if ($core.balance < card.pricing.openFee && card.by.handle !== $core.profile.handle && card.userSpecific.paidToAuthor === 0) {
            this._import("../dialogs/insufficient-funds-dialog.html").then(() => {
              return this.$.insufficientFunds.show().then((result) => {
                if (result && result.page && result.page === "balance") {
                  $router.goto("/balance");
                }
              });
            });
          } else {
            let context = {
              card: card,
              scrollTop: $app.scrollValue
            };
            if (this._parsedRoute) {
              context.returnPath = this._parsedRoute.path;
            }
            $router.updateContext({
              scrollTop: $app.scrollValue
            });
            $router.goto("/c/" + encodeURIComponent(card.id), context);
          }
        }
      }

      _onCardImpression(event) {
        let card = event.detail.card;
        let view = event.detail.view;
        if (card && view) {
          if ((!card.userSpecific.isPoster) && card.promoted && card.pricing.promotionFee && card.couponId) {
            $core.cardImpression(card.id, card.couponId, card.pricing.promotionFee, card.by.address);
            view.data.userSpecific.earnedFromAuthor = card.pricing.promotionFee;
          } else {
            $core.cardImpression(card.id);
          }
        }
      }

      _import(url) {
        return new Promise((resolve, reject) => {
          Polymer.importHref(this.resolveUrl(url), () => {
            resolve();
          }, (err) => {
            reject(err);
          });
        });
      }

      _onMoreUpdated(value) {
        // super class should implement to find out that more cards are avaiable or not
      }

      _fetchMore() {
        // called by super class when user requests more cards
        this._lastFetchTimestamp = (new Date()).getTime();
        return $core.getFeed(this._parsedRoute.feedName, this._parsedRoute.count, this._parsedRoute.cardId, this._lastCardId, this._parsedRoute.channel, this._promotedCardIds).then((feed) => {
          const cards = feed.cards;
          this._lastCardId = null;
          for (const card of cards) {
            if (card.promoted) {
              this._promotedCardIds.push(card.id);
            } else {
              this._lastCardId = card.id;
            }
          }
          this._appendItems(cards);
          this._moreAvailable = feed.moreAvailable && this._lastCardId ? true : false;
          this._onMoreUpdated(this._moreAvailable);
        }).catch((err) => {
          console.error(err);
          $app.showError(err);
        });
      }
    };
  })();
</script>