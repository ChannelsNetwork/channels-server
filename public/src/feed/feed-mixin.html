<dom-module id="feed-styles">
  <template>
    <style>
      :host {
        display: block;
        background: #fafafa !important;
      }

      .main {
        padding: 0 0 90px;
      }

      .spacer {
        height: 50px;
      }

      #feed {
        max-width: 1200px;
        margin: 0 auto;
        box-sizing: border-box;
      }

      #noItems {
        padding: 20px;
        font-size: 16px;
        letter-spacing: 0.05em;
      }
    </style>
  </template>
</dom-module>
<script>
  (function () {
    window.FeedMixin = (base) => class extends base {
      static get properties() {
        return {
          items: Array,
          iconMap: Object
        };
      }

      constructor() {
        super();
        this.iconMap = window._channelIcons;
      }

      _parseRoute(route) {
        // TODO: super class needs to reimplement
      }

      _onDataFetch(parsedRoute) {
        // TODO: super class may implement this to fetch specific data
      }

      onActivate(route) {
        $core.register().then(() => {
          // register event handlers
          this._resizeListener = _debounce(() => {
            this._onResize();
          }, 350);
          window.addEventListener("resize", this._resizeListener);
          this._onResize();

          let preventReload = false;
          if (route.context) {
            preventReload = route.context.preventReload;
          }
          if (preventReload && this.items && this.items.length) {
            $app.scrollTo(route.context.scrollTop);
            $router.context = null;
            return;
          }
          $router.context = null;

          // clear state
          this._setItems([]);
          this.$.feed.closeCard();
          if (this.$.promotedFeed) {
            this.$.promotedFeed.closeCard();
          }

          // parse route and fetch
          let parsedRoute = this._parseRoute(route);
          this._parsedRoute = parsedRoute;
          this._moreAvailable = false;
          this._promotedCardIds = [];
          if (parsedRoute) {
            this._onDataFetch(parsedRoute);
            return $core.getFeed(parsedRoute.feedName, parsedRoute.count, parsedRoute.cardId, null, parsedRoute.channel, this._promotedCardIds).then((feed) => {
              const cards = feed.cards;
              this._lastCardId = null;
              for (const card of cards) {
                if (card.promoted) {
                  this._promotedCardIds.push(card.id);
                } else {
                  this._lastCardId = card.id;
                }
              }
              this._setItems(cards);
              if (cards && cards.length) {
                this.$.noItems.classList.add("hidden");
              } else {
                this.$.noItems.classList.remove("hidden");
              }
              this._moreAvailable = feed.moreAvailable && this._lastCardId ? true : false;
              this._onMoreUpdated(this._moreAvailable);
            });
          }
        });
      }

      _setItems(items) {
        this.set("items", items);
      }

      _appendItems(items) {
        for (const item of items) {
          this.push('items', item);
        }
      }

      onDeactivate() {
        if (this._resizeListener) {
          window.removeEventListener("resize", this._resizeListener);
          this._resizeListener = null;
        }
      }

      _onResize() {
        this.$.feed.refreshLayout();
        if (this.$.promotedFeed) {
          this.$.promotedFeed.refreshLayout();
        }
      }

      _onCardClosed(event) {
        $app.setBarVisible(true);
      }

      _onCardOpenRequest(event) {
        let card = event.detail.item;
        if (card) {
          if ($core.balance < card.pricing.openFee && card.userSpecific.paidToAuthor === 0) {
            this._import("../dialogs/insufficient-funds-dialog.html").then(() => {
              return this.$.insufficientFunds.show().then((result) => {
                if (result && result.page && result.page === "balance") {
                  $router.goto("balance");
                }
              });
            });
          } else {
            let context = {
              card: card,
              scrollTop: $app.scrollValue
            };
            if (this._parsedRoute) {
              context.feed = this._parsedRoute.path;
            }
            $router.goto(['card', card.id], context, 'shift-left');
          }
        }
      }
      // _onCardOpenRequest(event) {
      //   let card = event.detail.card;
      //   if (card) {
      //     // hide toolbar and prevent 
      //     // toolbar auto scroll-hide behavior
      //     $app.setBarVisible(false);
      //     $app.preventScrollBehavior = true;

      //     // let server know card opened
      //     let cardItem = event.detail.item;
      //     if (cardItem) {
      //       $core.cardOpened(cardItem.id);
      //     }

      //     // open the card in the UI
      //     this.$.feed.openCard(card).then(() => {
      //       $app.preventScrollBehavior = false;
      //     }).catch((err) => {
      //       console.error(err);
      //       $app.preventScrollBehavior = false;
      //     });
      //   }
      // }

      _onCardImpression(event) {
        let card = event.detail.card;
        let view = event.detail.view;
        if (card && view) {
          if ((!card.userSpecific.isPoster) && card.promoted && card.pricing.promotionFee && card.couponId) {
            $core.cardImpression(card.id, card.couponId, card.pricing.promotionFee, card.by.address);
            view.data.userSpecific.earnedFromAuthor = card.pricing.promotionFee;
          } else {
            $core.cardImpression(card.id);
          }
        }
      }

      _onCardPay(event) {
        const card = event.detail.item;
        const cardView = event.detail.card;
        if (!card.userSpecific.isPoster) {
          if (card.pricing.openFee > 0 && card.userSpecific.paidToAuthor === 0) {
            card.userSpecific.paidToAuthor = card.pricing.openFee;
            $core.cardPay(card.id, card.pricing.openFee, card.by.address, card.cardType.royaltyAddress, card.cardType.royaltyFraction, card.referredBy ? card.referredBy.address : null).then((response) => {
              card.stats.revenue = response.totalCardRevenue;
              cardView.onPayment();
            }).catch((err) => {
              console.error("Failed to make card payment", err);
            });
          } else if (card.pricing.openFee < 0 && card.promoted && card.userSpecific.earnedFromAuthor === 0 && card.couponId) {
            card.userSpecific.earnedFromAuthor = -card.pricing.openFee;
            $core.cardOpenPaymentRedeem(card.id, card.couponId, -card.pricing.openFee, card.by.address).then(() => {
              cardView.onPayment();
            }).catch((err) => {
              console.error("Failed to make card payment", err);
            });
          }
        }
      }

      _import(url) {
        return new Promise((resolve, reject) => {
          Polymer.importHref(this.resolveUrl(url), () => {
            resolve();
          }, (err) => {
            reject(err);
          });
        });
      }

      _onMoreUpdated(value) {
        // super class should implement to find out that more cards are avaiable or not
      }

      _fetchMore() {
        // called by super class when user requests more cards
        return $core.getFeed(this._parsedRoute.feedName, this._parsedRoute.count, this._parsedRoute.cardId, this._lastCardId, this._parsedRoute.channel, this._promotedCardIds).then((feed) => {
          const cards = feed.cards;
          this._lastCardId = null;
          for (const card of cards) {
            if (card.promoted) {
              this._promotedCardIds.push(card.id);
            } else {
              this._lastCardId = card.id;
            }
          }
          this._appendItems(cards);
          this._moreAvailable = feed.moreAvailable && this._lastCardId ? true : false;
          this._onMoreUpdated(this._moreAvailable);
        }).catch((err) => {
          console.error(err);
          $app.showError(err);
        });
      }
    };
  })();
</script>