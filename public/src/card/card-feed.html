<link rel="import" href="card-view.html">
<link rel="import" href="../../bower_components/polymer/lib/elements/dom-repeat.html">
<link rel="import" href="../../bower_components/polymer/lib/utils/render-status.html">

<dom-module id="card-feed">
  <template>
    <style is="custom-style" include="iron-flex iron-flex-alignment">
       :host {
        display: block;
      }

      #container {
        width: 100%;
        box-sizing: border-box;
      }

      card-view {
        width: var(--grid-card-width);
        height: var(--grid-card-height, 500px);
        margin: 1.1%;
        box-sizing: border-box;
      }

      .openCardShell {
        margin: 10px 0;
        box-sizing: border-box;
        width: 100%;
      }
    </style>
    <div id="container" class="horizontal layout wrap">
      <dom-repeat items="[[items]]">
        <template>
          <card-view data="[[item]]" on-click="_onCardClick" on-card-close="_onCardClose"></card-view>
        </template>
      </dom-repeat>
    </div>
  </template>
  <script>
    class CardFeed extends Polymer.Element {
      static get is() { return "card-feed"; }
      static get properties() {
        return {
          nominalWidth: {
            type: Number,
            value: 300
          },
          items: Array
        };
      }

      constructor() {
        super();
        let ht = Math.min(Math.max(400, 0.6 * window.innerHeight), 520);
        let imgHt = ht < 480 ? "170px" : "250px";
        this.updateStyles({
          '--grid-card-height': ht + "px",
          '--card-img-height': imgHt
        });
      }

      connectedCallback() {
        super.connectedCallback();
        Polymer.RenderStatus.beforeNextRender(this, function () {
          this.refreshLayout();
        });
      }

      refreshLayout() {
        this._refreshAttempts = 0;
        this._refreshStyles();
      }

      _refreshStyles() {
        let w = this.offsetWidth;
        if (w === 0) {
          if (this._refreshAttempts < 10) {
            this._refreshAttempts++;
            setTimeout(() => {
              this._refreshStyles();
            }, 50);
          }
          return;
        }
        let cols = Math.max(1, Math.min(3, Math.floor(w / this.nominalWidth)));
        let colWidth = Math.floor((100 - (cols * 1.1 * 2)) / cols);
        if (this._colWidth != colWidth) {
          this._colWidth = colWidth;
          this.updateStyles({
            '--grid-card-width': colWidth + "%"
          });
        }
        this._refreshAttempts = 0;
        this._refreshOpenCardLayout();
      }

      _refreshOpenCardLayout() {
        if (this._openCard) {
          this._openCard.refreshLayout();
        }
      }

      _onCardClick(event) {
        this.dispatchEvent(new CustomEvent('card-click', { bubbles: true, composed: true, detail: { card: event.target, item: event.model.item } }));
      }

      _onCardClose(event) {
        this.closeCard();
      }

      closeCard() {
        if (this._openCard) {
          this._openCard.close();
          this._openCard.style.height = "";
          this._openCard = null;
        }
        if (this._openCardShell) {
          this._openCardShell.remove();
          this._openCardShell = null;
        }
      }

      openCard(card) {
        return new Promise((resolve, reject) => {
          let current = card;
          if (!current) {
            reject("Invalid card");
            return;
          }

          // find point of insertion for the opened card
          let currentTop = current.getBoundingClientRect().top;
          while (current.previousSibling) {
            if (current.previousSibling.nodeType !== Node.ELEMENT_NODE) {
              current = current.previousSibling;
            } else {
              let prevTop = current.previousSibling.getBoundingClientRect().top;
              if (prevTop == currentTop) {
                current = current.previousSibling;
              } else {
                break;
              }
            }
          }

          // if a card is already open, close it
          if (this._openCard) {
            this._openCard.close();
            this._openCard.style.height = "";
          }

          // Create a new node to contain the open card
          let node = document.createElement("div");
          node.classList.add('openCardShell');
          let shellHeight = window.innerHeight - 100;
          node.style.height = shellHeight + "px";
          current.parentElement.insertBefore(node, current);
          var nodeToRemove = this._openCardShell;
          this._openCardShell = node;

          // scroll container to offset the inserted node 
          // The 20 comes from the margin on the shell
          $app.shell.scrollTop = $app.shell.scrollTop + shellHeight + 20;

          // start animating the card
          var target = card;
          this._openCard = target;
          // callback after animation to resolve the promise 
          // and clear the state
          var _restoreStateAfterAnimation = (nodeToRemove) => {
            this._openCard.style.height = "0px";
            if (nodeToRemove) {
              setTimeout(() => {
                this.style.pointerEvents = "";
                nodeToRemove.remove();
                setTimeout(() => {
                  resolve();
                }, 150);
              }, 50);
            } else {
              this.style.pointerEvents = "";
              setTimeout(() => {
                resolve();
              }, 200);
            }
          };
          requestAnimationFrame(() => {
            // prevent user action when animating
            this.style.pointerEvents = "none";
            // Open card
            target.open(node).then(() => {
              // start scrolling to the opened card after 
              // a slight delay
              setTimeout(() => {
                $app.scrollTo(node, 700).then(() => {
                  _restoreStateAfterAnimation(nodeToRemove);
                }).catch((err) => {
                  _restoreStateAfterAnimation(nodeToRemove);
                });
              }, 300);
            }).catch((err) => {
              _restoreStateAfterAnimation(nodeToRemove);
            });
          });
        });
      }
    }
    window.customElements.define(CardFeed.is, CardFeed);
  </script>
</dom-module>